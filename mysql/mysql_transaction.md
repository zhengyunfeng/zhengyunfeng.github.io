# mysql事务
### 事务

所谓事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。MySQL提供了两种事务型的存储引擎：InnoDB和NDB Cluster。

### ACID

ACID，是指在可靠数据库管理系统（DBMS）中，事务(transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。这是可靠数据库所应具备的几个特性。下面针对这几个特性进行逐个讲解。

#### 1. 原子性

一个事务包含多个操作，这些操作要么全部执行，要么全都不执行。实现事务的原子性，要支持回滚操作，在某个操作失败后，回滚到事务执行之前的状态。

回滚实际上是一个比较高层抽象的概念，大多数DB在实现事务时，是在事务操作的数据快照上进行的(比如，MVCC)，并不修改实际的数据，如果有错并不会提交，所以很自然的支持回滚。

而在其他支持简单事务的系统中，不会在快照上更新，而直接操作实际数据。可以先预演一边所有要执行的操作，如果失败则这些操作不会被执行，通过这种方式很简单的实现了原子性。

#### 2. 一致性

一致性是指事务使得系统从一个一致的状态转换到另一个一致状态。事务的一致性决定了一个系统设计和实现的复杂度。事务可以不同程度的一致性：

强一致性：读操作可以立即读到提交的更新操作。

弱一致性：提交的更新操作，不一定立即会被读操作读到，此种情况会存在一个不一致窗口，指的是读操作可以读到最新值的一段时间。

最终一致性：是弱一致性的特例。事务更新一份数据，最终一致性保证在没有其他事务更新同样的值的话，最终所有的事务都会读到之前事务更新的最新值。如果没有错误发生，不一致窗口的大小依赖于：通信延迟，系统负载等。

其他一致性变体还有：

单调一致性：如果一个进程已经读到一个值，那么后续不会读到更早的值。

会话一致性：保证客户端和服务器交互的会话过程中，读操作可以读到更新操作后的最新值。

#### 3. 隔离性

并发事务之间互相影响的程度，比如一个事务会不会读取到另一个未提交的事务修改的数据。在事务并发操作时，可能出现的问题有：

脏读：事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据。

不可重复读：在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务B在事务A提交前读到的结果，和提交后读到的结果可能不同。不可重复读出现的原因就是事务并发修改记录，要避免这种情况，最简单的方法就是对要修改的记录加锁，这回导致锁竞争加剧，影响性能。另一种方法是通过MVCC可以在无锁的情况下，避免不可重复读。

幻读：在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。幻读是由于并发事务增加记录导致的，这个不能像不可重复读通过记录加锁解决，因为对于新增的记录根本无法加锁。需要将事务串行化，才能避免幻读。

事务的隔离级别从低到高有：

Read Uncommitted：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。

Read Committed：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。

Repeated Read：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。

Serialization：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。

通常，在工程实践中，为了性能的考虑会对隔离性进行折中。

#### 4. 持久性

持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 即使出现了任何事故比如断电等，事务一旦提交，则持久化保存在数据库中。

### mysql的实现方法

#### 1. 隔离性

锁机制+MVCC。通过MVCC使得事务隔离级别达到了可重复读，使用锁机制消除了幻读，实现了事务隔离。
MVCC全称Mutli Version Concurreny Control，多版本并发控制，也可称之为一致性非锁定读；它通过行的多版本控制方式来读取当前执行时间数据库中的行数据。实质上使用的是快照数据。参考[MySQL InnoDB引擎 MVCC并发控制](http://blog.csdn.net/tb3039450/article/details/66472579)
InnoDB在可重复读的事务隔离级别下消除了幻读，功劳应该归于Next-key Lock锁。参考[MySQL InnoDB中的行锁 Next-Key Lock消除幻读](http://blog.csdn.net/tb3039450/article/details/66475638)

#### 2. 持久性和原子性

通过数据库的redo log重做日志，来保证事务的持久性与原子性。

##### 2.1 持久性

重做日志由两部分组成：重做日志缓冲（内存）和重做日志文件（物理存储）。当事务提交（commit）时，必须先将该事务的所有日志写入到重做日志文件进行持久化，待事务提交操作完成才算完成。redo log重做日志基本上都是顺序写的。为了确保每次日志都写入重做日志文件，在每次将重做日志缓存写入重做日志文件后，InnoDB存储引擎都需要调用一次fsync（文件同步）操作。

##### 2.2 原子性

在InnoDB存储引擎中，重做日志都是以512字节进行存储的，称为重做日志块。若一个页中产生的重做日志数量大于512字节，那么需要分割为多个重做日志块进行存储。由于重做日志块的大小与磁盘扇区大小一样，都是512字节，因此重做日志的写入可以保证事务的原子性。重做日志块大小为512字节，但其中包含的有效存储为492字节，重做日志文件头占12字节，日志尾占8字节。

#### 3 一致性

通过数据库的undo log撤销日志，来保证事务的一致性。 
为了完成事务的回滚操作，在对数据库进行修改时，InnoDB存储引擎不但会产生redo log,还会产生一定量的undo logo。undo log是逻辑日志，只是将数据库逻辑地恢复到原来的样子，保证了事务的一致性（从一个状态转换为下一个一致性状态）。


###### [back to MySQL](https://zhengyunfeng.github.io/mysql/index)
